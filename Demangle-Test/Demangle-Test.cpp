// Demangle-Test.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <string>
#include <windows.h>
#include <fstream>
#include "PEParser.h"
namespace llvm {
    /// This is a llvm local version of __cxa_demangle. Other than the name and
    /// being in the llvm namespace it is identical.
    ///
    /// The mangled_name is demangled into buf and returned. If the buffer is not
    /// large enough, realloc is used to expand it.
    ///
    /// The *status will be set to a value from the following enumeration
    enum : int {
        demangle_unknown_error = -4,
        demangle_invalid_args = -3,
        demangle_invalid_mangled_name = -2,
        demangle_memory_alloc_failure = -1,
        demangle_success = 0,
    };

    char* itaniumDemangle(const char* mangled_name, char* buf, size_t* n,
        int* status);

    /// Calls the callback \c Callback with \c Ctx as an argument whenever a type is
    /// encountered. Returns true if \c MangledName couldn't be parsed.
    bool itaniumFindTypesInMangledName(const char* MangledName, void* Ctx,
        void (*Callback)(void*, const char*));


    enum MSDemangleFlags { MSDF_None = 0, MSDF_DumpBackrefs = 1 << 0 };
    char* microsoftDemangle(const char* mangled_name, char* buf, size_t* n,
        int* status, MSDemangleFlags Flags = MSDF_None);

    /// "Partial" demangler. This supports demangling a string into an AST
    /// (typically an intermediate stage in itaniumDemangle) and querying certain
    /// properties or partially printing the demangled name.
    struct ItaniumPartialDemangler {
        ItaniumPartialDemangler();

        ItaniumPartialDemangler(ItaniumPartialDemangler&& Other);
        ItaniumPartialDemangler& operator=(ItaniumPartialDemangler&& Other);

        /// Demangle into an AST. Subsequent calls to the rest of the member functions
        /// implicitly operate on the AST this produces.
        /// \return true on error, false otherwise
        bool partialDemangle(const char* MangledName);

        /// Just print the entire mangled name into Buf. Buf and N behave like the
        /// second and third parameters to itaniumDemangle.
        char* finishDemangle(char* Buf, size_t* N) const;

        /// Get the base name of a function. This doesn't include trailing template
        /// arguments, ie for "a::b<int>" this function returns "b".
        char* getFunctionBaseName(char* Buf, size_t* N) const;

        /// Get the context name for a function. For "a::b::c", this function returns
        /// "a::b".
        char* getFunctionDeclContextName(char* Buf, size_t* N) const;

        /// Get the entire name of this function.
        char* getFunctionName(char* Buf, size_t* N) const;

        /// Get the parameters for this function.
        char* getFunctionParameters(char* Buf, size_t* N) const;
        char* getFunctionReturnType(char* Buf, size_t* N) const;

        /// If this function has any any cv or reference qualifiers. These imply that
        /// the function is a non-static member function.
        bool hasFunctionQualifiers() const;

        /// If this symbol describes a constructor or destructor.
        bool isCtorOrDtor() const;

        /// If this symbol describes a function.
        bool isFunction() const;

        /// If this symbol describes a variable.
        bool isData() const;

        /// If this symbol is a <special-name>. These are generally implicitly
        /// generated by the implementation, such as vtables and typeinfo names.
        bool isSpecialName() const;

        ~ItaniumPartialDemangler();
    private:
        void* RootNode;
        void* Context;
    };
} 

// namespace llvm

//enum MSDemangleFlags { MSDF_None = 0, MSDF_DumpBackrefs = 1 << 0 };
//char* microsoftDemangle(const char* mangled_name, char* buf, size_t* n,
//    int* status, MSDemangleFlags Flags = MSDF_None);


void ShowHelp() {

    std::cout << "Usage:Demangle.exe CFucntion" << std::endl;


}

std::string GetTheDemangle(char* funcName) {
    int status;
    size_t NameLen;
   // char* temp = (char*)malloc(65535);
    char *temp = llvm::microsoftDemangle(funcName, nullptr, &NameLen, &status);
    std::cout <<"[+] 解析:" << temp << std::endl;
    return std::string(temp);
}
int main(int argc,char** argv)
{
   /* int status;
    size_t NameLen;
    char *temp=(char*)malloc(65535);
    temp = llvm::microsoftDemangle("?UrlEncode@crypto@util@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z", nullptr, &NameLen, &status);*/
    
    if (argc != 3) {
        ShowHelp();
         return 0;
    }
 
    std::shared_ptr<PEParser> pe(new PEParser(argv[1]));

    std::vector<char*> ImportNames = pe->GetImportTable(argv[2]);
    std::vector<std::string> DemangleResult{};
    for (int i = 0; i < ImportNames.size(); i++)
    {
        
        std::cout << "------------------------------------------------" << std::endl;
        std::cout << "[+] 函数名称:" << ImportNames[i] << std::endl;
        if (ImportNames[i][0] != '?' && ImportNames[i][0] == '_') {
            //std::string temp ="extern \"C\" __declspec(dllexpor) void "+
            std::string temp(ImportNames[i]);
            // 提取函数名
            std::string::size_type atPos = temp.find('@');
            std::string functionName = temp.substr(1, atPos - 1); 

            // 提取参数
            std::string::size_type lastAtPos = temp.find_last_of('@');
            std::string parameters = temp.substr(lastAtPos + 1); 
            int parameterValue = std::stoi(parameters);
            int paramDword = parameterValue / 4;
            int paramByte = parameterValue % 4;
            std::cout << "[+] 解析出参数可能为:" << paramDword << "个DWORD类型," << paramByte << "个BYTE(char)型" << std::endl;
            std::cout << "[+] 猜测的函数解析如下:" << std::endl;
            std::string result = "extern \"C\" _declspec(dllexport) int _stdcall "+ functionName+"(";
            for (int i = 0; i < paramDword; i++)
            {
                if (paramByte == 0 && i==paramDword-1) {
                    result+= "DWORD);";
                }
                else {
                    result += "DWORD,";
                }
            }
            for (size_t i = 0; i < paramByte; i++)
            {
                if (i == paramByte-1) {
                    result += "BYTE);";
                }
                else {
                    result += "BYTE,";
                }
            }
            
            std::cout << result << std::endl;
            DemangleResult.push_back(result);
            //DemangleResult.push_back()
        }
        else {
            DemangleResult.push_back(GetTheDemangle(ImportNames[i]));

        }
    }

    std::cout << "[+] 是否需要写出文件? (Y/N) :";
    std::string input;
    std::getline(std::cin, input);
    if (input.compare("Y") == 0) {
        std::cout << "[+] 请输入写出文件的路径:";
        std::string path;
        std::getline(std::cin, path);
        std::ofstream file(path);
        if (file.is_open()) {
            for (size_t i = 0; i < DemangleResult.size(); i++)
            {
                file << DemangleResult[i]+"\n";
            }
            std::cout << "[+] 写入成功！" << std::endl;

        }
        else {
            std::cerr << "[+] 无法打开此文件！" <<std::endl;
            return 0;
        }
    }
    else if(input.compare("N") == 0) {
        return 0;
    }
    else {
        std::cerr << "[-] 错误的输入！";
        return 0;
    }
    
    
   /* typedef int(*Demangle)(char* exportName,char*);

    FARPROC Daddr = GetProcAddress(LoadLibraryA("Demangle-Dll.dll"), "Demangle");
    Demangle pDemangle = (Demangle)(Daddr);*/
  /*  char *decodeName = argv[1];
    if (decodeName[0]!='?' && decodeName[0]=='_')
    {

        return 0;
    }
    if (decodeName[0] == '?') {
        temp = llvm::microsoftDemangle(decodeName);
        if (res == -1)
        {
            std::cerr << "error";
            return -1;
        }
        std::cout << temp;
    }
*/

    }

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
